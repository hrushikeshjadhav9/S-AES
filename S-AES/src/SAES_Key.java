/**

 */

import java.security.SecureRandom;

/** Simple-AES
 * 
 * Simple implementation of Advanced Encryption Standard. The main difference
 * between standard AES and S-AES is that AES does 10/12/14 rounds while S-AES 
 * only does 3 rounds. Also the block size for S-AES is 16-bits compared to AES
 * which uses 128-bit block sizes.
 *
 * @author Noel Niles
 * @version 1.0
 * @since 2014-10-28
 */
public class SAES_Key {
    
    /** S-AES State Matrix
     * The current state of the message. During encryption/decryption this 
     * matrix will change every round.
     **************************************************************************/
    private static byte[][] state;
    
    public SAES_Key(){
        state = new byte[2][2];
    }
    
    /** Round constants
     * 
     * These can be generated by x^i+2 and 0000 where x is a polynomial and the 
     * value of i depends on the round number. But since there are only 3 rounds
     * it's easier to just make these constants.
     **************************************************************************/
    private static final byte[] rCon = {(byte)0x80,(byte)0x30};
    
    /** S-Box
 
 S-AES lookup table used to swap nibbles in SAES_g function during key 
 expansion.
     **************************************************************************/
    private static final byte[][] SBox = 
        {{0x09, 0x04, 0x0a, 0x0b},
         {0x0d, 0x01, 0x08, 0x05},
         {0x06, 0x02, 0x00, 0x03},
         {0x0c, 0x0e, 0x0f, 0x07}};
    
    /** Inverse S-Box
     * 
     * Inverses the transformation performed in the S-Box. Used during 
     * decryption.
     **************************************************************************/
    private static final byte[][] invSBox = 
        {{0x0a, 0x05, 0x09, 0x0b}, 
         {0x01, 0x07, 0x08, 0x0f}, 
         {0x06, 0x00, 0x02, 0x03}, 
         {0x0c, 0x04, 0x0d, 0x0e}};

    /** Generates a random 2x2, 16-bit, matrix key. 
     * 
     * The 16-bits are arranged in a 2x2 matrix with 4-bits in each cell. Each 
     * cell actually contains 8-bits, but the 4 high bits are set to zero.
     * 
     * @return key: 2x2 matrix with one nibble in each cell.
     **************************************************************************/
    protected static byte[][] genKey(){
        SecureRandom random = new SecureRandom();
        byte bytes[] = new byte[1];
        byte key[][] = new byte[2][2];
        for (int col = 0; col < 2; col++) {
            for (int row = 0; row < 2; row++) {
                random.nextBytes(bytes);
                key[row][col] = (byte)((bytes[0] & 0xff) >>> 0x04);
            }
        }       
        return key;
    }

    /** Swaps the left and right nibbles in a word. 
     * 
     * Returns an array of two bytes, but only the first 4-bits from each byte 
     * are used the rest should be zero.
     * 
     * @param w: An 8-bit word.
     * @return rotWord: w with a circular shift performed on the nibbles.
     * @example rotNib(0x2d) = 0xd2
     **************************************************************************/
    protected static byte[] rotNib(byte w) {
        byte lnib = (byte) ((w & 0xf0) >>> 0x04);
        byte rnib = (byte) ((w & 0x0f));
        byte[] rotWord = {rnib, lnib};
        return rotWord;
    }
    
    /** Substitutes nibbles using a table look in S-AES S-Box. 
     * 
     * @param  nibArr: byte array that is output from the rotNib function.
     * @return subbedByte: a new nibble that is found using a table lookup from 
     *                     S-Box.
     **************************************************************************/
    protected static byte subNib(byte[] nibArr) {

        int x, y;
        x = (nibArr[0] >>> 0x02) & 0x03;
        y = nibArr[0] & 0x03;
        byte subNib1 = SBox[x][y];

        int xx, yy;
        xx = (nibArr[1] >>> 0x02) & 0x03;
        yy = nibArr[1] & 0x03;
        
        byte subNib2 = SBox[xx][yy];
        byte subbedByte = (byte) (((subNib1 & 0x0f) << 0x04) | (subNib2));
        return subbedByte;
    }
    
    /** S-AES SAES_g function.
     * 
     * Used during key expansion.
     * @param w: 8-bit word.
     * @param i: selects the round constant to use. Index into rCon[].
     * @return word: 8-bit word with nibbles rotated and SBox transform.
     * 
     * @TODO Build tests
     **************************************************************************/
    protected static byte SAES_g(byte w, int i) {
        byte[] nibArr = rotNib(w);
        byte subbedNibs = subNib(nibArr);
        return (byte) (subbedNibs ^ rCon[i]);
    }
    
    /** S-AES Key Expansion
     * 
     * Expands the 16-bit key into an array of shorts. The 3 shorts in the 
     * array are the 3 16-bit keys.
     * @param cipherKey: a 2x2 matrix generated by genKey()
     * @return key: array of 3 16-bit keys
     * 
     * @TODO Build tests. Should this return an array of 2x2 matrices?   
     **************************************************************************/
    protected static short[] keyExpansion(byte[][] cipherKey){
        // Array of 16-bit keys
        short key[] = new short[3];
        
        // w0-w5 are 8-bit words.
        byte w0 = (byte)((cipherKey[0][0] << 0x04) | cipherKey[0][1]);
        byte w1 = (byte)((cipherKey[1][0] << 0x04) | cipherKey[1][1]);
        byte w2 = (byte)(w0 ^ SAES_g(w1, 0));
        byte w3 = (byte)(w1 ^ w2);
        byte w4 = (byte)(w2 ^ SAES_g(w3, 1));
        byte w5 = (byte)(w3 ^ w4);
        
        // key[0-2] are the 16-bit keys. I have to AND with 0x00FF because if 
        // the most sig digit is one then Java will pad the rest of the bits 
        // with ones.
        key[0] = (short) ((w0 << 0x08) | (w1 & 0x00ff));
        key[1] = (short) ((w2 << 0x08) | (w3 & 0x00ff));
        key[2] = (short) ((w4 << 0x08) | (w5 & 0x00ff));
        return key;
    }
}

